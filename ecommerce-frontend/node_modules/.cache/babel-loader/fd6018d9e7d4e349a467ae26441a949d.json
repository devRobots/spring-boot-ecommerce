{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport * as React from 'react';\nimport KeyCode from \"rc-util/es/KeyCode\";\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\nimport Icon from '../icon';\nimport TextArea from '../input/TextArea';\n\nvar Editable =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Editable, _React$Component);\n\n  function Editable() {\n    var _this;\n\n    _classCallCheck(this, Editable);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Editable).apply(this, arguments));\n    _this.inComposition = false;\n    _this.state = {\n      current: ''\n    };\n\n    _this.onChange = function (_ref) {\n      var value = _ref.target.value;\n\n      _this.setState({\n        current: value.replace(/[\\r\\n]/g, '')\n      });\n    };\n\n    _this.onCompositionStart = function () {\n      _this.inComposition = true;\n    };\n\n    _this.onCompositionEnd = function () {\n      _this.inComposition = false;\n    };\n\n    _this.onKeyDown = function (_ref2) {\n      var keyCode = _ref2.keyCode; // We don't record keyCode when IME is using\n\n      if (_this.inComposition) return;\n      _this.lastKeyCode = keyCode;\n    };\n\n    _this.onKeyUp = function (_ref3) {\n      var keyCode = _ref3.keyCode,\n          ctrlKey = _ref3.ctrlKey,\n          altKey = _ref3.altKey,\n          metaKey = _ref3.metaKey,\n          shiftKey = _ref3.shiftKey;\n      var onCancel = _this.props.onCancel; // Check if it's a real key\n\n      if (_this.lastKeyCode === keyCode && !_this.inComposition && !ctrlKey && !altKey && !metaKey && !shiftKey) {\n        if (keyCode === KeyCode.ENTER) {\n          _this.confirmChange();\n        } else if (keyCode === KeyCode.ESC) {\n          onCancel();\n        }\n      }\n    };\n\n    _this.onBlur = function () {\n      _this.confirmChange();\n    };\n\n    _this.confirmChange = function () {\n      var current = _this.state.current;\n      var onSave = _this.props.onSave;\n      onSave(current.trim());\n    };\n\n    _this.setTextarea = function (textarea) {\n      _this.textarea = textarea;\n    };\n\n    return _this;\n  }\n\n  _createClass(Editable, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.textarea) {\n        this.textarea.focus();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var current = this.state.current;\n      var _this$props = this.props,\n          prefixCls = _this$props.prefixCls,\n          ariaLabel = _this$props['aria-label'],\n          className = _this$props.className,\n          style = _this$props.style;\n      return React.createElement(\"div\", {\n        className: classNames(prefixCls, \"\".concat(prefixCls, \"-edit-content\"), className),\n        style: style\n      }, React.createElement(TextArea, {\n        ref: this.setTextarea,\n        value: current,\n        onChange: this.onChange,\n        onKeyDown: this.onKeyDown,\n        onKeyUp: this.onKeyUp,\n        onCompositionStart: this.onCompositionStart,\n        onCompositionEnd: this.onCompositionEnd,\n        onBlur: this.onBlur,\n        \"aria-label\": ariaLabel,\n        autoSize: true\n      }), React.createElement(Icon, {\n        type: \"enter\",\n        className: \"\".concat(prefixCls, \"-edit-content-confirm\")\n      }));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var prevValue = prevState.prevValue;\n      var value = nextProps.value;\n      var newState = {\n        prevValue: value\n      };\n\n      if (prevValue !== value) {\n        newState.current = value;\n      }\n\n      return newState;\n    }\n  }]);\n\n  return Editable;\n}(React.Component);\n\npolyfill(Editable);\nexport default Editable;","map":{"version":3,"sources":["typography/Editable.jsx"],"names":["Editable","React","Component","current","target","value","keyCode","ctrlKey","altKey","metaKey","shiftKey","onCancel","KeyCode","onSave","nextProps","prevState","prevValue","newState","prefixCls","ariaLabel","className","style","classNames","polyfill"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport KeyCode from 'rc-util/lib/KeyCode';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\nimport Icon from '../icon';\nimport TextArea from '../input/TextArea';\nclass Editable extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.inComposition = false;\n        this.state = {\n            current: '',\n        };\n        this.onChange = ({ target: { value } }) => {\n            this.setState({ current: value.replace(/[\\r\\n]/g, '') });\n        };\n        this.onCompositionStart = () => {\n            this.inComposition = true;\n        };\n        this.onCompositionEnd = () => {\n            this.inComposition = false;\n        };\n        this.onKeyDown = ({ keyCode }) => {\n            // We don't record keyCode when IME is using\n            if (this.inComposition)\n                return;\n            this.lastKeyCode = keyCode;\n        };\n        this.onKeyUp = ({ keyCode, ctrlKey, altKey, metaKey, shiftKey, }) => {\n            const { onCancel } = this.props;\n            // Check if it's a real key\n            if (this.lastKeyCode === keyCode &&\n                !this.inComposition &&\n                !ctrlKey &&\n                !altKey &&\n                !metaKey &&\n                !shiftKey) {\n                if (keyCode === KeyCode.ENTER) {\n                    this.confirmChange();\n                }\n                else if (keyCode === KeyCode.ESC) {\n                    onCancel();\n                }\n            }\n        };\n        this.onBlur = () => {\n            this.confirmChange();\n        };\n        this.confirmChange = () => {\n            const { current } = this.state;\n            const { onSave } = this.props;\n            onSave(current.trim());\n        };\n        this.setTextarea = (textarea) => {\n            this.textarea = textarea;\n        };\n    }\n    static getDerivedStateFromProps(nextProps, prevState) {\n        const { prevValue } = prevState;\n        const { value } = nextProps;\n        const newState = {\n            prevValue: value,\n        };\n        if (prevValue !== value) {\n            newState.current = value;\n        }\n        return newState;\n    }\n    componentDidMount() {\n        if (this.textarea) {\n            this.textarea.focus();\n        }\n    }\n    render() {\n        const { current } = this.state;\n        const { prefixCls, 'aria-label': ariaLabel, className, style } = this.props;\n        return (<div className={classNames(prefixCls, `${prefixCls}-edit-content`, className)} style={style}>\n        <TextArea ref={this.setTextarea} value={current} onChange={this.onChange} onKeyDown={this.onKeyDown} onKeyUp={this.onKeyUp} onCompositionStart={this.onCompositionStart} onCompositionEnd={this.onCompositionEnd} onBlur={this.onBlur} aria-label={ariaLabel} autoSize/>\n        <Icon type=\"enter\" className={`${prefixCls}-edit-content-confirm`}/>\n      </div>);\n    }\n}\npolyfill(Editable);\nexport default Editable;\n"]},"metadata":{},"sourceType":"module"}